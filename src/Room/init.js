/**
 * TODO run this only in claimed room
 *
 * Design and save a build plan
 * 0) check whether if this room is new to me or it's a netural room
 * 1) clean all old structure except storage and terminal
 * 2) check source count & decide which plan to use
 * 3) Design layout (ignore container)
 * 4) Save layout to memory
 */
Room.prototype.init = function() {
  /*
  FloorPlan is about structure placement
  area: {area:"source",pos:RoomPosition,range:number}
  */

  //
  this.find(FIND_HOSTILE_CONSTRUCTION_SITES)
    .forEach(s => s.remove());
  this.find(FIND_HOSTILE_STRUCTURES)
    .forEach(s => (s.structureType === STRUCTURE_TERMINAL || s.structureType === STRUCTURE_STORAGE) ? 0 : s.destroy());


  // Check terrian & get layout
  if (!this.memory.floorMap) {
    let floorPlan;
    const sources = this.find(FIND_SOURCES);
    const allPos = this.findSpaceForSquare(7);
    if (sources.length === 2) { // 2 source
      for (s of sources) {
        const closest = s.pos.findClosestByPath(allPos);
        if (closest.inRangeToRoomObject(s, 10)) {
          // TODO DEBUG
          // TODO place 30 extension layout
        } else {
          // TODO place 6 stars of 5 layout = 1 spawn, 1 link, 1 tower, 30 extensions
          // IDEA block range < 4 after each star placed
        }
      }
    } else { // 1 source
      // TODO Design 60 extension layout
      const allPos = this.findSpaceForSquare(11);
      for (source of sources) {
        let pos = source.pos.findClosestByPath(allPos, {
          algorithm: "dijkstra"
        });
        if (source.pos.inRangeToPos(pos, 15)) {
          // TODO place 60 extension outpost layout
        } else {
          // TODO place 12 stars of 5 layout
        }
      }
    }
    // TODO save the final layout to memory
    // TODO setup area & save it to memory
  }
};

/* Generated by planner
{
  "structures": {
    "extension": {
      "pos": [{
        "x": 7,
        "y": 19
      }, {
        "x": 6,
        "y": 20
      }]
    },
    "container": {
      "pos": [{
        "x": 13,
        "y": 28
      }, {
        "x": 14,
        "y": 28
      }]
    }
  }
}
*/

/**
 * Find all RoomPositions where a square of given size can fit in.
 *
 * @param  {number} sideLength the length of the side of the square
 * @param  {RoomPosition[]} [optPos] Anything else you might want to avoid, eg. structures
 * @return {RoomPosition[]} All center tiles of such empty squares
 */
Room.prototype.findSpaceForSquare = function(sideLength, optPos) {
  // The index of `avoid` is the distance at which it should treat the values as obstacles
  // For example, index 2 makes all tiles in radius 2 around the controller "unwalkable"

  // parameter check
  const radius = ~~(sideLength / 2);
  optPos = optPos || [];
  optPos.forEach(o => o.pos ? o = o.pos : undefined);

  // map restrict distance to room position
  const restrictedArea = {
    0: optPos,
    1: [...this.find(FIND_SOURCES), ...this.find(FIND_MINERALS)].map(o => o.pos),
    3: [this.controller.pos],
  };

  // Iteration from right to left, bottom to top.
  const terrain = this.getTerrain();
  let grid = new PathFinder.CostMatrix; // a 50 * 50 empty matrix
  let spots = [];
  let y = 50;
  while (y--) {
    let x = 50;
    nextPos: while (x--) {

      // set gird to default (0) if it's a wall
      if (terrain.get(x, y) === TERRAIN_MASK_WALL) {
        continue;
      }

      // set gird tp default (0) if it's in range to an object of avoidance
      for (const range in restrictedArea) {
        const restrictedPos = restrictedArea[range];
        if (restrictedPos && restrictedPos.some(p => p.inRangeToXY(x, y, range))) {
          // move on to next RoomPosition upon finding object of avoidance
          continue nextPos;
        }
      }

      // the "score" of a tile is the minimum score of its right, bottom, and bottom-right tiles + 1
      const score = Math.min(grid.get(x + 1, y), grid.get(x, y + 1), grid.get(x + 1, y + 1)) + 1;
      grid.set(x, y, score);

      // add to result if such point exceed the score
      if (score >= sideLength) spots.push(new RoomPosition(x + radius, y + radius, this.name));

      // visualization
      this.visual.text(score, x, y, {
        strokeWidth: 0.1,
        opacity: 0.3
      });
    }
  }
  return spots.length ? spots : null;
};
/**
 * Plan road, using PathFinder
 *
 * @param   {RoomPosition|RoomObject}  start  the start position.
 * @param   {RoomPosition|RoomObject}  goal  a goal or goal position.
 * @param   {Object}  [opts]  options
 * @param   {string}  [opts.roomName]  overwirte name
 * @param   {number}  [opts.plainCost]  set up plain cost
 * @return  {Object}  Same as [PathFinder.search()]{@link https://docs.screeps.com/api/#PathFinder.search}
 */
Room.planRoad = function(start, goal, opts) {
  const searchOpts = Object.assign({
    roomCallback: roomCallbackPrioritizeRoad,
  }, opts);

  if (start.pos) start = start.pos;
  if (goal.pos) goal = goal.pos;
  const roomName = start.roomName;
  const plannedRoad = PathFinder.search(
    start, goal, searchOpts);
  new RoomVisual(roomName)
    .poly(plannedRoad.path);
  plannedRoad.path.forEach(p => p.createConstructionSite(STRUCTURE_ROAD));

  return plannedRoad;
};

// Room.planRoad(new RoomPosition(21,21,"W26N39"),new RoomPosition(10,44,"W26N39"))
/**
 * [roomCallback description]
 *
 * @param   {string}  roomName  [roomName description]
 * @param   {Object}  [opts]      [opts description]
 * @param   {number}  [opts.plainCost=2]      [opts description]
 * @param   {number}  [opts.swampCost=10]      [opts description]
 * @param   {number}  [opts.plainCost=254]      [opts description]
 *
 * @return  {[type]}            [return description]
 */
function roomCallbackPrioritizeRoad(roomName, opts) {
  // Avoid: minerals, source, existed unwalkable rObj -> set 0xff
  // priorize: existed road/roadConstructSite -> set 1
  // All cost = maintainance cost; -> set number based on terrain; > 1
  if (Memory.rooms[roomName] && Memory.rooms[roomName].avoid) return false;
  if (!opts) opts = {};
  const plainCost = opts.plaincost || 2;
  const swampCost = opts.swampCost || Math.min(CONSTRUCTION_COST_ROAD_SWAMP_RATIO * plainCost, 0xff - 1);
  const wallCost = opts.wallCost || Math.min(CONSTRUCTION_COST_ROAD_WALL_RATIO * plainCost, 0xff - 1);

  let costs = new PathFinder.CostMatrix;
  const terrain = Game.map.getRoomTerrain(roomName);

  let y = 50;
  while (y--) {
    let x = 50;
    while (x--) {
      switch (terrain.get(x, y)) {
        case TERRAIN_MASK_WALL:
          costs.set(x, y, wallCost);
          break;
        case TERRAIN_MASK_SWAMP:
          costs.set(x, y, swampCost);
          break;
        default:
          costs.set(x, y, plainCost);
          break;
      }
    }
  }

  // visiblity check
  let room = Game.rooms[roomName];
  if (!room) return costs;

  // set sources/mineral as unwalkable
  [...room.find(FIND_SOURCES), ...room.find(FIND_MINERALS)].forEach(r => costs.set(r.pos.x, r.pos.y, 0xff));

  // set all struture/constructureSite except container, road, my rampart as unwalkable.
  room.find(FIND_STRUCTURES)
    .forEach(s => {
      if (s.structureType === STRUCTURE_ROAD) {
        // set road
        costs.set(s.pos.x, s.pos.y, 1);
      } else if (s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER && (s.structureType !== STRUCTURE_RAMPART || !s.my)) {
        // set unwalkable structures
        costs.set(s.pos.x, s.pos.y, 0xff);
      }
    });
  room.find(FIND_CONSTRUCTION_SITES)
    .forEach(s => {
      if (s.structureType === STRUCTURE_ROAD) {
        // set road
        costs.set(s.pos.x, s.pos.y, 1);
      } else if (s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER && (s.structureType !== STRUCTURE_RAMPART || !s.my)) {
        // set unwalkable structures
        costs.set(s.pos.x, s.pos.y, 0xff);
      }
    });
  return costs;
}
